---
title: "practical3.Rmd"
author: "John McIntyre"
date: "11/11/2019"
output: html_document
---

```{r, echo = FALSE}
results = "hide"
```


```{r, include = FALSE, cache = FALSE}
library(knitr)
opts_knit$set(out.format = "latex")
knit_theme$set(knit_theme$get("greyscale0"))

options(replace.assign=FALSE,width=50)

opts_chunk$set(fig.path='figure/graphics-', 
               cache.path='cache/graphics-', 
               fig.align='center', 
               dev='pdf', fig.width=5, fig.height=5, 
               fig.show='hold', cache=FALSE, par=TRUE)
knit_hooks$set(crop=hook_pdfcrop)

knit_hooks$set(par=function(before, options, envir){
    if (before && options$fig.show!='none') {
        par(mar=c(3,3,2,1),cex.lab=.95,cex.axis=.9,
            mgp=c(2,.7,0),tcl=-.01, las=1)
}}, crop=hook_pdfcrop)
```

```{r, echo = FALSE, include = FALSE}
library("lubridate")
```
```{r, echo = FALSE}
today()
```

# Programming: Practical 3
We wish to determine the properties on which a player is most likely to land during a game of monopoly. To simplify things, we assume there is only a single player, ignore everything to do with money and also ignore the `Get out of Jail Free Cards'.

## Monopoly: overview of the problem 
* Begin the game on GO;
* Roll the dice and move forward the number displayed on the dice
* Make a note of the new position.
    +  If we land on `Chance' or 'Community Chest', draw a card;
    +  If we land on `Go To Jail', move to Jail;
    +  If we move, make a note of the new position;
* Go back to step 2

After rolling the dice 100,000 times or so, stop.

## Dice rolling 
When we roll a single die, each side has an equal probability of occurring. This
means we can use the **sample** function to simulate a die roll:

```{r, eval = FALSE}
sample(1:6, 1)
```

To roll two dice, we simply call this function:

```{r}
RollTwoDice = function() {
  total = sample(1:6, 1) + sample(1:6, 1)
  return(total)
}
```


#### The Monopoly board
In monopoly there are forty properties or squares, see table at the
end of this practical for a complete list. If we set the first square `Go' to be
number 1, then we can represent all forty squares as a vector in R. For example,

```{r}
## This creates a vector of 40 values;
## All values are initially zero
landings = numeric(40)
```

Then, when we land on a square we simply increase the associated **landings** entry by one. Suppose we landed on `Old Kent Rd', we would represent this as:

```{r}
landings[2] = landings[2] + 1
```
since `Old Kent Road' is square 2 (see table).

#### Going round the board
Our first go at simulating Monopoly will ignore community chest, chance cards,
and the `Go To Jail' square. This means that we are simply going round the
board. The code in the **SimulateMonopoly** function, rolls the dice a certain number of times corresponding to the value we assign to no_of_rolls, and stores the squares that are landed on in the vector **landings**. 

```{r}
SimulateMonopoly = function(no_of_rolls) {    
  landings = numeric(40)
  ## Start at GO
  current = 1
  for(i in 1:no_of_rolls) {
    current = current + RollTwoDice()
    if(current > 40) {
      current = current - 40
    }
    landings[current] = landings[current] + 1
  }
  return(landings)
}
no_of_rolls = 50000
```

```{r, echo = FALSE}
no_of_rolls = 100
```

We can then call the function using:
```{r}
sim = SimulateMonopoly(no_of_rolls)
```

```{r, echo = FALSE}
# no_of_rolls = 2000000
# sim1 = SimulateMonopoly(no_of_rolls)
# saveRDS(sim1, file=data/sim1.RData")
sim = readRDS("sim1.RData")
library("tibble")
sim = as_tibble(sim)
```

We can then plot the results
```{r, F1, fig.keep='none', tidy=FALSE}
library("dplyr")
sim = sim %>% 
  mutate(probability = value/sum(value))
library("ggplot2")
monopoly_plot = ggplot(sim, aes(x = 1:40, y = probability)) +
  geom_point() +
  labs(x = "Square", y = "Probability", caption = "Probability of landing on monopoly square.") +
  ylim(0, 0.06)
monopoly_plot
```

```{r, ref.label="F1", dev='pdf', fig.align="center", echo=FALSE}
```

#### Incorporating Community Chest Cards
There are three community chest squares on the board - squares 3, 18 and 34. In
the code below we will just consider square 3. There are sixteen cards in total,
hence the probability of drawing any particular card is 1/16. In the code below
we will **only implement the first two community chest cards**:

```{r}
CommunityChest = function(current) {
  goto = current
  u = runif(1)
  if(u < 1/16) {
    goto = 1#Move to Go
  }else if(u < 2/16) {
    goto = 11#Go To Jail  :(
  }
  return(goto)
}
```

This function takes in the **current** position, with probability
1/16 we `Move to Go', with probability 1/16 we `Go to Jail' and with probability
14/16 we stay in our current position. We now alter the **simulate** function
to incorporate the **CommunityChest** function:



